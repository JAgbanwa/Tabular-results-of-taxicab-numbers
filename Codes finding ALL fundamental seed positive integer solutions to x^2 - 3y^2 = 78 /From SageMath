def find_all_fundamental_solutions_theoretically():
    """
    Find ALL fundamental solutions to x^2 - 3y^2 = 78 using proper number theory.
    
    For a Pell-type equation x^2 - Dy^2 = N, the fundamental solutions are
    those with |x| ≤ √(N*U) and |y| ≤ √(N/(D-ε)) where U is the fundamental unit,
    but this is complicated. Better approach: find all solutions with
    |x| ≤ √(N*(U+1)/2) or similar.
    
    Actually, the correct bound: For D=3, all fundamental solutions satisfy:
    |x| ≤ √(78 * (2+√3)) ≈ √(78 * 3.732) ≈ √291.1 ≈ 17.06
    and |y| ≤ √(78/(2√3-3))? This is messy.
    
    The proper theoretical approach:
    """
    
    K.<sqrt3> = QuadraticField(3)
    
    print("="*70)
    print("THEORETICAL DETERMINATION OF ALL FUNDAMENTAL SOLUTIONS")
    print("="*70)
    
    # Fundamental unit
    eps = 2 + sqrt3
    print(f"Fundamental unit: ε = {eps} (norm = {eps.norm()})")
    
    # The regulator
    reg = log(eps[0])  # log of the fundamental unit
    print(f"Regulator: {reg.n()}")
    
    # For x^2 - 3y^2 = 78, we need to find all solutions in the fundamental domain
    # This means finding all (x,y) with 0 < y < something and x > 0
    
    # The correct method: Find all solutions to the congruence conditions
    # and then check which are in different orbits under the unit group
    
    print("\nStep 1: Find all solutions modulo something...")
    
    # First, find all solutions to x^2 ≡ 78 (mod 3)
    # 78 mod 3 = 0, so x must be divisible by 3
    print("Since 78 ≡ 0 (mod 3), we have x ≡ 0 (mod 3)")
    print("Let x = 3u, then equation becomes: 9u^2 - 3y^2 = 78 → 3u^2 - y^2 = 26")
    
    print("\nStep 2: Solve 3u^2 - y^2 = 26")
    print("This is a Pell-type equation in (u,y)")
    
    # Now find fundamental solutions to 3u^2 - y^2 = 26
    # This is equivalent to y^2 - 3u^2 = -26
    
    print("\nStep 3: Find fundamental solutions to y^2 - 3u^2 = -26")
    
    # Search systematically with increasing bounds until we find all congruence classes
    # The number of fundamental solutions is finite and can be found by
    # checking all y with |y| ≤ √(26*3.732) ≈ 9.85 for the negative Pell
    
    u_fundamentals = []
    y_fundamentals = []
    
    # Search for solutions to y^2 - 3u^2 = -26
    for u in range(1, 50):  # Reasonable bound for u
        y_squared = 3*u^2 - 26
        if y_squared > 0 and y_squared.is_square():
            y = sqrt(y_squared)
            u_fundamentals.append(u)
            y_fundamentals.append(Integer(y))
            print(f"Found: u={u}, y={y} → 3({u})^2 - ({y})^2 = {3*u^2 - y^2}")
    
    print(f"\nFound {len(u_fundamentals)} solutions to 3u^2 - y^2 = 26")
    
    # Convert back to original variables: x = 3u
    print("\nStep 4: Convert back to original equation:")
    original_solutions = []
    for i in range(len(u_fundamentals)):
        x = 3*u_fundamentals[i]
        y = y_fundamentals[i]
        if x^2 - 3*y^2 == 78:
            original_solutions.append((x, y))
            print(f"Original solution: ({x}, {y}) → {x}^2 - 3·{y}^2 = {x^2 - 3*y^2}")
    
    # Now we need to determine which of these are fundamental
    # A solution is fundamental if it cannot be obtained from a smaller solution
    # by multiplying by a power of the fundamental unit
    
    print("\nStep 5: Determine which are truly fundamental (different orbits under the unit group)")
    
    # Sort by |x| + |y|√3 (the size in the field)
    original_solutions.sort(key=lambda sol: sol[0] + sol[1]*sqrt3.n())
    
    # Create the elements in Q(√3)
    elements = [x + y*sqrt3 for x, y in original_solutions]
    
    # Group them by orbits under multiplication by powers of eps
    orbits = []
    used = [False] * len(elements)
    
    for i in range(len(elements)):
        if used[i]:
            continue
        
        orbit = [original_solutions[i]]
        used[i] = True
        
        for j in range(i+1, len(elements)):
            if used[j]:
                continue
            
            # Check if elements[j] = elements[i] * eps^k for some integer k
            ratio = elements[j] / elements[i]
            if abs(ratio.norm()) == 1:
                # Check if it's a unit (power of eps or -eps^k)
                if ratio in K.unit_group() or -ratio in K.unit_group():
                    orbit.append(original_solutions[j])
                    used[j] = True
        
        orbits.append(orbit)
    
    print(f"\nFound {len(orbits)} distinct orbits:")
    fundamental_seeds = []
    for i, orbit in enumerate(orbits):
        print(f"Orbit {i+1}: {orbit}")
        # The smallest in each orbit is a fundamental seed
        orbit.sort(key=lambda sol: sol[0] + sol[1]*sqrt3.n())
        fundamental_seeds.append(orbit[0])
        print(f"  Fundamental seed: {orbit[0]}")
    
    print("\n" + "="*70)
    print(f"CONCLUSION: The fundamental seed solutions are: {fundamental_seeds}")
    print("="*70)
    
    # Verify that these generate all solutions
    print("\nVerification by generating first few solutions from each seed:")
    for x0, y0 in fundamental_seeds:
        elem = x0 + y0*sqrt3
        print(f"\nFrom ({x0}, {y0}):")
        for n in range(3):
            sol = elem * eps^n
            x = sol[0]._integer_()
            y = sol[1]._integer_()
            print(f"  n={n}: ({x}, {y}) → {x}^2 - 3·{y}^2 = {x^2 - 3*y^2}")
    
    return fundamental_seeds

# Run the theoretical analysis
fundamental_seeds = find_all_fundamental_solutions_theoretically()
